##   C语言是什么

汇编语言

国际标准：

ANSI C - C89/C90 - 标准

C99/C11 并不流行 - 很多编译器不支持



C语言是一门面向过程的计算机编程语言



主要编译器：Clang、GCC、WIN-TC、SUBLIME、MSVC、Turbo C等





## 2. 语法部分

C语言规定，变量要定义在当前代码块的最前面，放后面可能会编译失败

### 2.1 主函数main

程序的入口，程序是从main的第一行代码开始执行的，且只有一个main函数

```c
int main ()   //int表示main函数调用返回一个整型
{
    return 0  // 返回0
}
```



### 2.2 数据类型

向内存申请空间，创建变量

```c
int ch = 20; // 向内存申请4个字节大小的空间，用来存放20
```



#### 2.2.1 int 整型

占4个字节，32个比特位，可以表示的最大值是2^32-1

```c
int main
{
    int ch = 20;
    return 0
}
```



#### 2.2.1 char 字符数据类型

```c
int main
{
    char ch = 'a';
    return 0
}
```

#### 2.2.1 short 短整型

占2个字节，16个比特位，可以表示的最大值是2^16-1

```c
int main
{
    short ch = 213;
    return 0
}
```



#### 2.2.1 long 长整型

标准规定sizeof(long) 大于等于 sizeof(int) 就可以，没有规定具体大小

占4个字节，32个比特位，可以表示的最大值是2^32-1

```c
int main
{
    long ch = 100;
    return 0
}
```



#### 2.2.1 long long 更长的整型

占8个字节，64个比特位，可以表示的最大值是2^64-1

```c
int main
{
    long long ch = 100;
    return 0
}
```



#### 2.2.1 float 单精度浮点型

```c
int main
{
    float ch = 1000.1f;
    return 0
}
```



#### 2.2.1 double 双精度浮点型

```c
int main
{
    double ch = 1000.111111;
    return 0
}
```



#### 为什么整型有多个类型:

####  

### 2.2 库函数

c语言本身提供的函数

```c
#incloude<stdio.h>   // std - 标准(standard)  i - 输入(input)  o - 输出(output) 


printf("")  // 打印
printf("%c","hello")  // 打印字符格式的数据（char ）
printf("%d", 100)  // 打印整型十进制数据
printf("%f", 100)  // 打印浮点型
printf("%lf", 100)  // 打印双精度浮点型
printf("%p", 100)  // 以地址的形式打印
printf("%x", 100)  // 打印十六进制数字
printf("%o", 100)  // 打印十六进制数字
printf(sizeof(100))  // 打印类型/变量所占内存大小（字节）
printf(sizeof(int))  // 打印类型/变量所占内存大小（字节）
printf(sizeof a)  // 打印类型/变量所占内存大小（字节） 当参数是变量时，()可以省略
    
// 加法
int num1 = 110;
int num2 = 2000
scanf("%d%d", &num1, &num2) // & - 取地址符(字面意思，取对应地址取得保存的数据)   scanf函数可以让我们通过键盘输入对应的值(标准输入输出符)


// a.c
int g_val = 110
// b.c
extern int g_val; // extern 用来声明外部变量
printf("g_val = %d\n", g_val)
    
char arr1[] = "abc"
printf("g_val = %d\n", strlen(arr1)); // strlen 用来计算字符串长度
```

```c
#define _CRT_SECURE_NO_WARNINGS 1 // 很多库函数都是不安全的，用这个可以让编译器忽略
#include <stdio.h>
int main()
{
  int num1 = 0;
  int num2 = 0;
  int sum = 0;

  scanf("%d%d", &num1, &num2);
  sum = num1 + num2;
  printf("sum = %d\n", sum);
  return 0;
}
```



### 2.3 变量常量

```c
int ch = 70  // 定义在代码块之外的变量就是全局变量
int main
{
    // 局部变量和全局变量名建议不要相同，局部变量优先级大于全局变量
    auto int ch = 80 //  定义在代码块之内的变量就是局部变量-自动变量(前面都省略了auto关键字)
    printf("%d", ch) // 80
}
```

#### 2.3.1 变量的作用域和生命周期

##### 2.3.1.1 作用域

> 作用域（scope）,程序设计概念，通常来说，一段程序代码中所用到的名字并不是总是有效/可用的
>
> 而限定这个名字的可用性的代码范围就是这个名字的作用域

1. 局部变量的作用域是变量所在的局部范围
2. 全局变量的作用域是整个工程

##### 2.3.1.2 生命周期

> 变量的生命周期指的是变量的创建到变量的销毁之间的一个时间段

1. 局部变量的生命周期是：进入作用域生命周期开始，出作用域生命周期结束
2. 全局变量的生命周期是：整个程序的生命周期



#### 2.3.2 常量

##### 2.3.2.1 字面常量

```c
int main()
{
    3; // 字面常量
    return 0
}
```

##### 2.3.2.2 const 修饰的常变量

```c
int main()
{
    const int a = 3; // const 常属性    表示一个具有常属性的变量，本质上还是变量
    
    
    const int a = 10;
  	int arr[a] = {0}; // 报错，因为a是变量，但是需要常量
    return 0
}
```

##### 2.3.2.3 #define 定义的标识符常量

```c
#define MAX 10
int main()
{
    int arr[MAX] = {0};
    return 0
}
```



##### 2.3.2.4 枚举常量

```c
enum Sex  // enum 是枚举关键字
{
    MALE,  // 枚举常量  默认值为0
    FEMALE  // 枚举常量  默认值为1
};
int main()
{
    enum Sex s = MALE;
    return 0;
}
```



### 2.4 字符串

```"hello bit.\n"``` 这种由双引号引起来的字符成为字符串字面值，或者简称字符串

注：字符串的结束标志是一个\0的转义字符。在计算字符串长度的时候\0是结束标签，不算字符串内容



```c
#include<stdio.h>
#include<string.h>  // strlen 的库函数
int main()
{
    // "abc" -- 'a' 'b' 'c' '\0'    \0表示0（ASCII编码）
    char arr1[] = "abc";  // -> abc  用数组存储字符串
    char arr2[] = {'a','b','c'}; // -> abc??   abc后面没有结束标志，打印了一些随机值
    char arr3[] = {'a','b','c', 0}; // -> abc   
    char arr3[] = {'a','b','c', '\0'}; // -> abc
    printf("%d\n", strlen(arr1)); // -> 3
    printf("%d\n", strlen(arr2)); // -> 6 有些编译器是其他数字，但是总体必须超过3
    printf("%d\n", strlen(arr1)); // -> 3
    return 0
}
```

### 2.5 转义字符

```c
// \ddd
printf("\c\n", "\132"); // -> Z  八进制转十进制  1*8^2 + 3*8^1 + 2*8^0 = 90  对应ASCII码表为Z
// \xdd
printf("\c\n", "\x61"); // -> a  十六进制转十进制 6*16^1 + 6*16^0 = 96 + 1 = 97  对应ASCII码表为a
```



| 转义字符                     | 意义                                                         | ASCII码值（十进制） | 用发                   |
| ---------------------------- | ------------------------------------------------------------ | ------------------- | ---------------------- |
| \a                           | 响铃(BEL)，警告字符，蜂鸣                                    | 007                 |                        |
| \b                           | 退格(BS) 将当前位置移到前一列。 退格符                       | 008                 |                        |
| \f                           | 换页(FF)，将当前位置移到下页开头。 进纸符                    | 012                 |                        |
| \n                           | 换行(LF) ，将当前位置移到下一行开头。 换行符                 | 010                 |                        |
| \r                           | 回车(CR) ，将当前位置移到本行开头。回车符                    | 013                 |                        |
| \t                           | 水平制表(HT) （跳到下一个TAB位置）。水平制表符               | 009                 |                        |
| \v                           | 垂直制表(VT)。垂直制表符                                     | 011                 |                        |
| \\\                          | 用于表示一个反斜杠，防止它被解释为一个转义字符               | 092                 |                        |
| \\'                          | 用于表示字符常量'                                            | 039                 |                        |
| \\"                          | 用于表示一个字符串内部的双引号                               | 034                 |                        |
| \0                           | 空字符(NULL)                                                 | 000                 |                        |
| \ddd（反斜杠后面加三个数值） | 1到3位八进制数所代表的任意字符。 如：\130x                   | 三位八进制          |                        |
| \xhh                         | 1到2位十六进制所代表的任意字符。 如：\x30 0                  | 二位十六进制        |                        |
| \\?                          | 在书写连续多个问号时使用，防止他们被解析为三字母词（  ??+) -> 早期叫做三字母词  ） |                     | printf("(sdfa\?\?)\n") |

### 2.6 选择语句

```c
#include<stdio.h>
int main()
{
    int input = 0;
    scanf("%d", &input);
    if(input = 0)
        printf("走上人生巅峰");
    else
        printf("卖烤红薯“);
}
```

### 2.7 循环语句

#### 2.7.1 while 语句

```c
int main()
{
    int line = 0;
    while(line < 1000) 
    {
        printf("敲代码");
        line++;
    }
    printf("代码量够了");
    return 0
}
```



#### 2.7.2 for 语句

#### 2.7.3 do ... while 语句



### 2.8 函数（自定义函数）

```c
int Add(int x, int y)  // 函数名和函数参数
{ // 函数体
    int z = x + y;
    return z
}
int main()
{
    int a = 100;
    int b = 100;
    int sum = 0;
    sum = Add(a,b);
    return 0
}
```

### 2.9 数组

数组： 一组相同类型元素的集合

```c
int a[10] = {0,1,2,3,4,5,6,7,8,9};
// 通过下标拿取对应的值   a[2] -> 2
char ch[3] = {"1","2","3"};
```

### 2.10 操作符

1. 下标引用操作符

   ```c
   int arr[10] = {0};
   arr[0]; // []  下标引用操作符
   ```

2. 函数调用操作符

   ```c
   int Add(int a,int b) 
   {
       int sum = a + b;
       return sum;
   }
   
   int a=3;
   int b=4;
   Add(a,b) //  () 函数调用操作符
   ```

3. 

#### 2.10.1 算术运算符

#####  +

```c
int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    sum = a + b;
}
```

#####  -

```c
int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    sum = a - b;
}
```

#####  * 

```c
int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    sum = a * b;
}
```

#####  /

```c
int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    sum = a / b;
}
```

#####  % 取模

```c
int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    sum = a % b;
}
```



#### 2.10.1 移位运算符(二进制)

##### >> 左移

```c
int a = 1;
// 00000000 00000000 00000000 00000001    整型1占四个字节-32bit位
int b = a<<1;
// 00000000 00000000 00000000 00000010    有效数值左移，左边删除超过的位数，右边补0
int c = a>>1;
// 00000000 00000000 00000000 00000000    有效数值右移，右边删除超过的位数，左边补0
```



##### << 右移

#### 2.10.2 位操作符(二进制)

##### & 按位与

都为1的时候才取1，否则取0

```c
int main()
{
    int a = 3;  // 二进制： 011
    int b = 5;  // 二进制： 101
    int sum = a&b; //二进制:001  ->  1     
}
```



##### ^ 按位异或

对应的二进制位相同则为0，相异则为1 

```c
int main()
{
    int a = 3; //  二进制:  011
    int b = 5; //  二进制:  101
    int sum = a^b;//二进制: 110   -> 6
}
```



##### | 按位或

只要有1就取一，否则取0

```c
int main()
{
    int a = 3; //  二进制:  011
    int b = 5; //  二进制:  101
    int sum = a|b;//二进制: 111   -> 7
}
```

##### ~按位取反

```c
int main()
{
    int a = 3; //  二进制:  00000000 00000000 00000000 00000011
    int b = ~a; //  二进制: 11111111 11111111 11111111 11111100   -4
}
```



#### 2.10.3 赋值运算符

```c
=
// 以下都是复合运算符
+=
-=
*=
/=
&=
^=
|=
>>=
<<=
```

#### 2.10.4 单目操作符

```c
!a;
```

```C
// !  逻辑反操作


// -  负值


// +  正值
// &  取地址
// sizeof  操作符的类型长度（以字节为单位）
// ~  对一个数的二进制按位取反
// -- 前置 先--再使用，后置-- 先使用再-- 
// ++ 前置 先++再使用，后置++ 先使用再++
// *  间接访问操作符（解引用操作符）
// (类型)  强制类型转换
int a = (int)3.14
```

#### 2.10.5 双目操作符

+、-、*、/、%

#### 2.10.6 三目操作符

```c
int main()
{
    int a = 0;
    int b = 2;
    int c = a > b ? a : b;
    return 0;
}
```

#### 2.10.7 关系操作符



#### 2.11 原码、反码、补码

##### 预备知识

由于计算机的硬件决定，**任何存储于计算机中的数据，其本质都是以二进制码存储**。

根据冯·诺依曼提出的经典计算机体系结构框架，一台计算机由运算器、控制器、存储器、输入和输出设备组成。其中运算器**只有加法运算器**，没有减法运算器（据说一开始是有的，后来由于减法运算器硬件开销太大，被废了）。

所以计算机中没办法直接做减法的，它的减法是通过加法实现的。现实世界中所有的减法也可以当成加法的，减去一个数可以看作加上这个数的相反数，但前提是要先有负数的概念，这就是为什么不得不引入一个符号位。**符号位在内存中存放的最左边一位，如果该位位0，则说明该数为正；若为1，则说明该数为负。**

而且从硬件的角度上看，只有正数加负数才算减法，正数与正数相加，负数与负数相加，其实都可以通过加法器直接相加。

原码、反码、补码的产生过程就是为了解决计算机做减法和引入符号位的问题。



##### 2.11.1 机器数

> 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
>
> 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
>
> 那么，这里的 00000011 和 10000011 就是机器数。

##### 2.11.2 真值

> 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1



##### 2.11.3 **十进制与二进制的相互转换**

1. 十进制转换为二进制，分为整数部分和小数部分。

> **整数部分采用除2倒取余法**，具体做法：用2去除十进制整数，可以得到一个商和余数；在用2去除商，又会得到一个商和余数，如此进行，知道商为0时为止，然后把先的到的余数作为二进制的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。
> **小数部分采用乘2取整法**，具体做法：用2乘十进制小数，可以得到积，将积中的整数部分取出，在用2乘余下的小数部分，又得到一个积，在将积中的整数部分取出，如此进行，直到积中的小数部分为0，此时0或1为二进制的最后一位，或者达到所要求的精度为止，然后把取出的整数部分按顺序排列起来，先取得整数作为二进制小数的最高位有效位，后取的整数作为低位有效位。

2. 二进制转换为十进制，方法：**按权相加法**，即将二进制每位上的数乘以权，然后相加之和即是十进制数。

##### 2.11.4 原码

原码：**是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值**。

以带符号位的四位二进制数为例：1010，最高位为1表示这是一个负数，其它三位010，即0*2^2+1*2^1+0*2^0=2，所以1010表示十进制数-2。

![img](D:\note\sedimentation\image\v2-57b3e01e66c6053cdadb46b7072a9235_720w.webp)

部分正负数的二进制原码表示

原码的表示法很简单，虽然出现了+0和-0，但是直观易懂。于是开始运算——

> 0001+0010=0011，1+2=3；
> 0000+1000=1000，+0+(-0)=-0；
> 0001+1001=1010，1+(-1)=-2。

于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

**原码的特点：**

1. 原码表示直观、易懂，与真值转换容易。

2. 原码中0有两种不同的表示形式，给使用带来了不便。

> 通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。

3. 原码表示加减运算复杂。

> 利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。



##### 2.11.5 反码

原码最大的问题就在于一个数加上它的相反数不等于0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

反码：**正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反**。

以带符号位的四位二进制数为例：3是正数，反码与原码相同，则可以表示为0011；-3的原码是1011，符号位保持不变，低三位按位取反，所以-3的反码为1100。

![img](D:\note\sedimentation\image\v2-7c6c75a9685fb78814aae117cf5bc5f0_720w.webp)

部分正负数的二进制反码表示

再试着用反码的方式解决一下原码的问题——

> 0001+1110=1111，1+(-1)=-0；
> 1110+1100=1010，(-1)+(-3)=-5。

互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加的出错了。

**反码的特点：**

1. 在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即0为正；1为负。
2. 在反码表示中，数值0有两种表示方法。
3. 反码的表示范围与原码的表示范围相同。

**反码表示在计算机中往往作为数码变换的中间环节。**



##### 2.11.6 补码

补码：**正数的补码等于它的原码；负数的补码等于反码+1**（这只是一种算补码的方式，多数书对于补码就是这句话）。

其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。

如果有兴趣了解补码的严格说法，建议可以看一下《计算机组成原理》，它会用“模”和“同余”的概念，严谨地解释补码。

------

**一、补码的思想**

补码的思想，第一次见可能会觉得很绕，但是如果肯停下来仔细想想，绝对会觉得非常美妙。

补码的思想其实就是来自于生活，只是我们没注意到而已，如时钟、经纬度、《易经》里的八卦等。**补码的思想其实就类似于生活中的时钟**。

如果说现在时针现在停在10点钟，那么什么时候会停在八点钟呢？

> 简单，过去隔两个小时的时候是八点钟，未来过十个小时的时候也是八点钟。
> 也就是说时间倒拨2小时，或正拨10小时都是八点钟。
> 也就是10-2=8，而且10+10=8。
> 这个时候满12，说明时针在走第二圈，又走了8小时，所以时针正好又停在八点钟。

所以12在时钟运算中，称之为模，超过了12就会重新从1开始算了。

也就是说，10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。

既然是等效的，那么在时钟运算中，减去一个数，其实就相当于加上另外一个数（这个数与减数相加正好等于12，也称为同余数），这就是补码所谓运算思想的生活例子。

在这里，再次强调原码、反码、补码的引入是为了解决做减法的问题。在原码、反码表示法中，我们把减法化为加法的思维是减去一个数等于加上这个数的相反数，结果发现引入符号位，却因为符号位造成了各种意想不到的问题。

但是从上面的例子中，可以看到其实减去一个数，对于数值有限制、有溢出的运算（模运算）来说，其实也相当于加上这个数的同余数。

也就是说，不引入负数的概念，就可以把减法当成加法来算。

------

**二、补码的实例**

接下来就做一做四位二进制数的减法（先不引入符号位）。

0110-0010，6-2=4，但是由于计算机中没有减法器，没法算。

这时候，想想时钟运算中，减去一个数，是可以等同于加上另外一个正数（同余数），这个数与减数相加正好等于模。

也就是四位二进制数最大容量是多少？其实就是2^4=16（10000）。

那么-2的同余数，就等于10000-0010=1110，16-2=14。

既然如此，0110-0010=0110+1110=10100，6-2=6+14=20。

按照这种算法得出的结果是10100，但是对于四位二进制数最大只能存放4位，如果低四位正好是0100，正好是想要的结果，至于最高位的1，计算机会把它放入psw寄存器进位位中，8位机会放在cy中，x86会放在cf中，这里不做讨论。

这个时候，再想想在四位二进制数中，减去2就相当于加上它的同余数（至于它们为什么同余，还是建议看《计算机组成原理》）。

但是减去2，从另一个角度来说，也是加上-2，即加上-2和加上14得到的二进制结果除了进位位，结果是一样的。如果我们把1110的最高位看作符号位后就是-2的补码，**这可能也是为什么负数的符号位是1，而不是0**。

![img](https://pic4.zhimg.com/80/v2-15756f4b9ee904787eefefdfdda748ff_720w.webp)

部分正负数的二进制补码表示

到这里，原码、反码的问题，补码基本解决了。

在补码中也不存在-0了，因为1000表示-8。

**补码的特点：**

1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负。但补码的符号可以看做是数值的一部分参加运算。

> 正数的补码表示就是其本身，负数的补码表示的实质是把负数映像到正值区域，因此加上一个负数或减去一个正数可以用加上另一个数（负数或减数对应的补码）来代替。
> 从补码表示的符号看，补码中符号位的值代表了数的正确符号，0表示正数，1表示负数；而从映像值来看，符号位的值是映像值的一个数位，因此在补码运算中，符号位可以与数值位一起参加运算。

2. 在补码表示中，数值0只有一种表示方法。

3. 负数补码的表示范围比负数原码的表示范围略宽。纯小数的补码可以表示到-1，纯整数的补码可以表示到-2^n。

由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此**计算机中均采用补码进行加减运算**。

------

**三、为什么负数的补码的求法是反码+1**

因为负数的反码加上这个负数的绝对值正好等于1111，在加1，就是10000，也就是四位二进数的模，而负数的补码是它的绝对值的同余数，可以通过模减去负数的绝对值得到它的补码，所以负数的补码就是它的反码+1。



##### 2.11.7 总结

```txt
          5        -5
原码： 0000 0101 1000 0101
反码： 0000 0101 1111 1010
补码： 0000 0101 1111 1011


                          0
原码      00000000 00000000 00000000 00000000    原码
~按位取反  11111111 11111111 11111111 11111111    补码
负数在内存中存储的是二进制的补码，我们使用的是原码
最高位表示符号
反码(减一) 11111111 11111111 11111111 11111110    反码
原码      10000000 00000000 00000000 00000001    原码


3
00000000 00000000 00000000 00000011   原码
11111111 11111111 11111111 11111100   按位取反 补码
11111111 11111111 11111111 11111011   高位减1，低位补1   反码
10000000 00000000 00000000 00000100   原码      -4


-2
10000000 00000000 00000000 00000010 原码
11111111 11111111 11111111 11111101 反码：原码符号位不变，其他位取反
11111111 11111111 11111111 11111110 补码：反码加一

```

只要是整数，内存中存储的都是二进制的补码

正数：原码--反码--补码 相同



#### 2.12 表达式

##### 2.12.1 逗号表达式





#### 2.13 常见关键字

```C
// auto  自动变量=》局部变量前面都省略了一个auto关键字
// break
// case
// char
// const
// continue
// default
// do 
// dobule
// else
// enum
// extern  引入外部符号
// float  单精度
// for
// goto
// if


// int  int是一个有符号数，可以存储正数和负数
signed int;   // int 完整写法，前面的被省略了
unsigned int;  // 无符号int，永远是正数


// long



// register 寄存器关键字
register int a = 10; // 建议把a定义成寄存器变量


// return
// short
// signed  有符号数 省略了 有正负数之分
// sizeof
// static  静态  1 .修饰局部变量 局部变量生命周期变长 2. 修饰全局变量  改变变量的作用域-让静态的全局变量只能在自己所在的源文件内部使用，出了源文件就没法再使用了  3. 修饰函数 改变了函数的链接属性，普通的函数具有外部链接属性。被static修饰后外部链接属性变为内部链接属性
// struct  结构体关键字
// switch
// typedef  类型定义-类型重定义
typedef unsigned int u_int; // 将unsigned int重命名为u_int
u_int num = 20;  // 等同于 unsigned int num = 20

// union  联合体/共用体
// unsigned  无符号位  永远是正数
// void
// volatile
// while
```

![image-20221012234246786](D:\note\sedimentation\image\image-20221012234246786.png)

寄存器内存小，但是处理速度非常快





### 3. 结构体

#### 3.1 顺序结构

### 3.2 选择结构

选择语句

```c
int main()
{
    int age = 8;
    if(age<18)
    {
        printf("未成年");
    	if(age < 8)
        {
            printf("我在上小学");
        }
    }
    else if(age > 18) 
    {
        printf("早就成年了");
    }
    else
    {
        printf("刚刚成年");
    }
}
```

```c
int main()
{
    int a = 1;
    switch (a) // switch接受的是整形，   整形表达式 
    {
    	case 1:  // case 后是整形表达式
        	printf("我到中年了");
       		break;
    	case 2:
        case 3:
        	printf("我到老年了");
        	break;
    	default:
        	printf("我不知道");
        	break;
    }
    return 0;
}
```

进阶语法

```c
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    // 1
    int ret = 0;
    char password[20] = { 0 };
    printf("请输入密码：");
    // 将数据放到输入缓冲区，当输入完会将结果拿出来（有结果就会结束这段代码的运行，没有结果就会等待），但是由于敲了回车键，输入缓冲区中还会遗留一个\n(打印出来会是10)
    // scanf只会获取空格前面的东西。 如果输入的值是 '12321 abc'这种带空格的，scanf会将12321拿出，留下空格加abc
    scanf("%s", password);
    printf("请确认(Y/N):");
    // 从输入缓冲区中拿数据，如果没有拿到数据就会等待用户输入，如果有拿到数据就会直接结束这段代码。上面遗留了一个\n所以直接拿到数据结束代码
    // 
    getchar();
    // 因为当前输入缓冲区中已经没有了数据，所以会等待用户输入新的数据，回车后拿到结果
    ret = getchar();
    if (ret == 'Y') 
    {
        printf("确认成功\n");
    }
    else
    {
        printf("确认失败\n");
    }
    
    
    
    // 2
    int ret = 0;
    char password[20] = { 0 };
    printf("请输入密码：");
    // scanf只会获取空格前面的东西。 如果输入的值是 '12321 abc'这种带空格的，scanf会将12321拿出，留下空格加abc
    scanf("%s", password);
    printf("请确认(Y/N):");
    // 拿走空格（只会拿走一个字符）
    getchar();
	// 拿到a并直接结束此段代码
    ret = getchar();
    if (ret == 'Y') 
    {
        printf("确认成功\n");
    }
    else
    {
        printf("确认失败\n");
    }
    
    
    // 3
    
    int ret = 0;
    char password[20] = { 0 };
    printf("请输入密码：");
    scanf("%s", password);
    printf("请确认(Y/N):");
    // 通过循环从输入缓冲区中拿到所有不为\n的字符
    while((ch=getchar())!= '\n')
    {
        ;
    }
    ret = getchar();
    if (ret == 'Y') 
    {
        printf("确认成功\n");
    }
    else
    {
        printf("确认失败\n");
    }
    return 0; 
}
```

![image-20221024232833673](D:\self\note\sedimentation\image\image-20221024232833673.png)



### 3.3 循环结构

```c
int main()
{
    int i = 1;
    while (i < 100)
    {
        i++;
        if (i % 2 == 0)
        {
            continue;
        }
        printf("%d", i);
    }
    return 0;
}
```

```c
int main()
{
    int ch = 0;
    // ctrl + z
    // EOF 文件结束标志  end of file -> -1
    while ((ch=getchar()) != EOF)
    {
        putchar(ch);
    }
    return 0;
}
```

```c
int main()
{
    
}
```



### p8接着看  35分钟

## 计算机单位

为什么一个int类型（4字节  32bit）最大存储数是2^32-1 而不是2^31-1

​		11111111 11111111 11111111 11111111     32位  左边最大位是2^31，但是不是最大保存数，只是左边最大再进一位就是下面的数，所以就可以用2^32-1来表示最大位数

​        100000000 00000000 00000000 00000000    33位 左边最大位是2^32，2^32-1

​         

### 1. 比特位(bit)-最小单位

一个比特位可以用来存一个二进制位(0或者1)

### 2. 字节(byte)

一个字节对应八个比特位

### 3. kb

一个kb是1024个字节

### 4. mb

一个mb是1024个kb

### 5. gb

一个gb是1024个mb

### 6. tb

一个tb是1024个gb

### 7. pb

一个pb是1024个tb









